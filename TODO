xerobase
--------
OIItem
  Base device for widgets that are part of the OI (buttons, scales, switches)
  Stores the item number (button or axis) for the widget on the HID device
  Defines a contract for the actual widgets to follower

OIButton
  A button on a joystick (digital input)
  Can be level, level inverted, low to high, or high to low
  Processes the button state once per robot loop via the setValue method

OIAxisSwitch
  A switch on an axis (analog input)
  Can be any number of positions in an equal range from -1 to +1
  Processes the axis state once per robot loop via the setValue method

OIAxisScale
  A scale on an axis with a specific mapping (think automode knob)
  Can be any number of positions in an range given when the object is created
  Processes the axis state once per robot loop via the setValue method

HIDDevice
  Base device for all HID OI devices (gamepads & OI controller)
  Stores reference to PhoenixOISubsystem
  Store index of the HID device
  
OIDevice derived from HIDDevice
  Stores an array of OIItems
  The index of the OItem is used as a handle
  Provides methods for mapping buttons, axisScale, or axisSwitch

DriverGamepad derived from HIDDevice
  Processes POV item to nudge the robot
  Processes the joystick axis to drive the robot per previous years approach
    - Slow button
	- Boost button

TeleopController derived from Controller Base
  does nothing right now, but we should keep this place holder

CondAction derived from Action
  Runs one of two actions based on value in the action being equal to a value in the setting parser
  start() method evaluates condition and assigns one of acttrue_ or actfalse_ to actactive_, calls start() on actactive_
  run() method calls run() on actactive_
  isDone() method isDone() on actactive_
  Members:
    ActionPtr acttrue_, actfalse_ actactive_ ;

ComputeAction derived from Action
  takes two scale (s1 & s2) and two named parameters (p1 & p2) and a result name
  result gets put into settingsParser = s1 * value of (p1) + s2 * value of (p2)

AutoMode
  Stores reference to robot and name of automode
  Maintains a stack of ActionSequence shared pointers for creating auto modes
  Contains methods common to xerobase for easily creating auto mode steps
    createCondition
	compute

TestController derived from Controller Base
  TBD we need to define how the test mode is going to work	

phoenix
-------
Drivebase Subsystem (Matthew)
- Extract CAN indices, encoder indices, solenoid indices from paramter file
- Create and store: motors
- Create and store: NavX 
- Create and store: encoders
- Create and store: shifter solenoid
- Compute State: left, right, and total distance
- Compute State: robot angle
- Create directive: turn on motors to fixed voltage
- Create directive: turn on motors for fixed amount of time at a fixed voltage
- Create directive: drive straight for a fixed distance
- Create directive: rotate a fixed angle
- Create directive: path follower

Lifter Subsystem
- Create directive: go to low gear
- Create directive: climb hold position

Collector Subsystem (Meg)
- Extract cube detect sensor from parameter file
- Aggregrate       : Grabber and Intake Subsystems
- Create and store : cube detector sensor
- Calculate status : has cube (more than just sensor status, has time window with hystersis)
- Create directive : collect cube
- Create directive : timed eject cube (speed is argument, can be a parameter)
- Create directive : sensor eject cube (speed is argument, can be a parameter)

LiftingCollector Subsystem (Nicole)
- Aggregrate       : Collector and Lifter Subsystems
- Create directive : CollectCube
                     o  Lifter action - go to floor
                     o  Collector action - collect cube
                     o  Lifter action - go to exchange

PhoenixOISubsystem derived from Subsystem
  Can be enabled or disabled
  Create DriverGamepad and PhoenixOIDevice
  If we have time create PhoenixGunnerGamepad
  Test for OI to be sure it is connected
  In compute state, call compute state on each of the device (if in operator mode), run actions

PhoenixOIDevice derived from OIDevice
  Create all OI widgets (floor, exchange, switch, scale, collect, eject, drop, climb, wings,
                          eject_slow, intake_auto, calibrate, lifter_up, lifter_down, climb_disabled
						  lifter_high_power, automode, grabber_auto, grabber_mode, intake_mode,
						  collect_end_height)
  Create actions to bind to widgets
  Capture the lifter stop logic when using joystick

PhoenixRobot Subsystem
  Aggregrate LiftingCollector, TankDrive, Wings, and OISubsystem

PhoenixTeleopController derived from TeleopController
  Enables OI subsystem when create
  Disables OI subsystem when destroyed

PhoenixAutoController derived from AutoController
  Reads automode selector and maps to settingsParser int value
  Reads game specific data and maps each of the three values to settings Parser string
  Creates an auto mode program based on automode switch (and game data?)

Automode Scenarios

Start	Switch  Scale	Action
------------------------------
Center	Right   XXXXX	Score switch front, pickup second cube, score right side
Center  Right   Right   Score switch front, pickup second cube, move toward right scale
Center  Right   Left    Score switch front, pickup second cube, move toward left scale
Center  Left    Right   Score switch front, pickup second cube, move toward right scale
Center  Left    Left    Score switch front, pickup second cube, move toward left scale

Left    Left    XXXXX   Score switch side, move up to cube on back of switch
Left    XXXXX   Left    Score scale corner, pickup second cube, score on scale
Left    Right   Left    Score scale corner, pickup second cube, score on scale
Left    Right   Left    Score scale back side (complemtary mode)
Left    Right   Right   Cross line
Left    Right   Right   Score opposite scale

Right   Right   XXXXX   Score switch side, move up to cube on back of switch
Right   XXXXX   Right   Score scale corner, pickup second cube, score on scale
Right   Left    Right   Score scale corner, pickup second cube, score on scale
Right   Left    Right   Score scale back side (complentary mode)
Right   Left    Left    Cross line
Right   Left    Left    Score opposite scale
